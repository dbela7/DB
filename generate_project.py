from __future__ import annotations

from pathlib import Path


def text(lines: list[str]) -> str:
    return "\n".join(lines) + "\n"


FILES: dict[str, str] = {}

# --- config.ini (a te szerver útvonaladdal előtöltve) ---
FILES["config.ini"] = text([
    "[paths]",
    "; Elsődleges: közös adatbázis útja (meghajtóbetűjeles vagy UNC)",
    r"db_path = N:\Biztonsag_szervezet\Közös\Szabadság tervezés\data\tervezo.db",
    "",
    "; Export mappa (később használjuk)",
    r"export_dir = N:\Biztonsag_szervezet\Közös\Szabadság tervezés\exports",
])

# --- main.py ---
FILES["main.py"] = text([
    "import sys",
    "from PySide6.QtWidgets import QApplication",
    "",
    "from app.bootstrap import bootstrap_app",
    "",
    "",
    "def main():",
    "    app = QApplication(sys.argv)",
    "    w = bootstrap_app()",
    "    w.show()",
    "    sys.exit(app.exec())",
    "",
    "",
    "if __name__ == '__main__':",
    "    main()",
])

# --- app package ---
FILES["app/__init__.py"] = text(["# app package"])

FILES["app/paths.py"] = text([
    "from __future__ import annotations",
    "",
    "import os",
    "import sys",
    "from pathlib import Path",
    "",
    "",
    "def app_base_dir() -> Path:",
    "    # exe mappa (PyInstaller), vagy projekt root (dev)",
    "    if getattr(sys, 'frozen', False):",
    "        return Path(sys.executable).resolve().parent",
    "    return Path(__file__).resolve().parent.parent",
    "",
    "",
    "def default_config_path() -> Path:",
    "    return (app_base_dir() / 'config.ini').resolve()",
    "",
    "",
    "def default_db_path_next_to_exe() -> Path:",
    "    return (app_base_dir() / 'data' / 'tervezo.db').resolve()",
    "",
    "",
    "def ensure_dir(p: Path) -> None:",
    "    p.mkdir(parents=True, exist_ok=True)",
    "",
    "",
    "def normalize_path(p: str) -> str:",
    "    p = p.strip().strip('\"')",
    "    return os.path.normpath(p)",
])

FILES["app/config.py"] = text([
    "from __future__ import annotations",
    "",
    "import configparser",
    "from pathlib import Path",
    "",
    "from app.paths import default_config_path",
    "",
    "",
    "def ensure_default_config_exists() -> Path:",
    "    path = default_config_path()",
    "    if not path.exists():",
    "        path.write_text('[paths]\\n', encoding='utf-8')",
    "    return path",
    "",
    "",
    "def read_config() -> configparser.ConfigParser:",
    "    cfg = configparser.ConfigParser()",
    "    path = default_config_path()",
    "    try:",
    "        cfg.read(path, encoding='utf-8')",
    "    except UnicodeDecodeError:",
    "        cfg.read(path, encoding='cp1250')",
    "    return cfg",
    "",
    "",
    "def get_path_value(key: str) -> str | None:",
    "    cfg = read_config()",
    "    if cfg.has_section('paths') and cfg.has_option('paths', key):",
    "        v = cfg.get('paths', key).strip()",
    "        return v or None",
    "    return None",
    "",
    "",
    "def set_path_value(key: str, value: str) -> None:",
    "    cfg = read_config()",
    "    if not cfg.has_section('paths'):",
    "        cfg.add_section('paths')",
    "    cfg.set('paths', key, value)",
    "    with open(default_config_path(), 'w', encoding='utf-8') as f:",
    "        cfg.write(f)",
    "",
    "",
    "def get_config_db_path() -> str | None:",
    "    return get_path_value('db_path')",
    "",
    "",
    "def set_config_db_path(p: str) -> None:",
    "    set_path_value('db_path', p)",
    "",
    "",
    "def get_export_dir() -> str | None:",
    "    return get_path_value('export_dir')",
])

FILES["app/db.py"] = text([
    "from __future__ import annotations",
    "",
    "import sqlite3",
    "from pathlib import Path",
    "",
    "from PySide6.QtWidgets import QFileDialog, QMessageBox",
    "",
    "from app.config import get_config_db_path, set_config_db_path",
    "from app.paths import default_db_path_next_to_exe, ensure_dir, normalize_path",
    "",
    "",
    "class Database:",
    "    def __init__(self) -> None:",
    "        self.db_path: Path | None = None",
    "        self.conn: sqlite3.Connection | None = None",
    "",
    "    def _connect(self, db_path: Path) -> None:",
    "        ensure_dir(db_path.parent)",
    "        conn = sqlite3.connect(str(db_path), timeout=8.0)",
    "        conn.row_factory = sqlite3.Row",
    "        conn.execute('PRAGMA foreign_keys = ON;')",
    "        conn.execute('PRAGMA busy_timeout = 8000;')",
    "        conn.execute('PRAGMA journal_mode = DELETE;')",
    "        conn.execute('PRAGMA synchronous = FULL;')",
    "        self.conn = conn",
    "        self.db_path = db_path",
    "",
    "    def connect_or_prompt_and_connect(self, parent=None) -> None:",
    "        # 1) config.ini",
    "        cfg_path = get_config_db_path()",
    "        if cfg_path:",
    "            p = Path(normalize_path(cfg_path))",
    "            try:",
    "                self._connect(p)",
    "                return",
    "            except Exception as e:",
    "                QMessageBox.warning(",
    "                    parent,",
    "                    'Adatbázis hiba',",
    "                    f'A config.ini-ben megadott DB nem nyitható:\\n{p}\\n\\nHiba: {e}\\n\\n'",
    "                    'Megpróbálom az exe melletti adatbázist, vagy válassz másikat.'",
    "                )",
    "                self.conn = None",
    "                self.db_path = None",
    "",
    "        # 2) exe mellett",
    "        candidate = default_db_path_next_to_exe()",
    "        try:",
    "            self._connect(candidate)",
    "            return",
    "        except Exception:",
    "            self.conn = None",
    "            self.db_path = None",
    "",
    "        # 3) tallózás",
    "        self._prompt_for_db(parent)",
    "",
    "    def _prompt_for_db(self, parent=None) -> None:",
    "        QMessageBox.information(",
    "            parent,",
    "            'Adatbázis kiválasztása',",
    "            'Nem található használható adatbázis.\\n\\n'",
    "            'Válaszd ki a meglévő SQLite fájlt, vagy adj meg egy új fájlnevet (a program létrehozza).'",
    "        )",
    "        file_path, _ = QFileDialog.getSaveFileName(",
    "            parent,",
    "            'SQLite adatbázis kiválasztása / létrehozása',",
    "            '',",
    "            'SQLite DB (*.db);;Minden fájl (*.*)'",
    "        )",
    "        if not file_path:",
    "            raise SystemExit('Nem lett kiválasztva adatbázis fájl.')",
    "        p = Path(normalize_path(file_path))",
    "        self._connect(p)",
    "        set_config_db_path(str(p))",
    "",
    "    def execute(self, sql: str, params: tuple = ()):",
    "        assert self.conn is not None",
    "        return self.conn.execute(sql, params)",
    "",
    "    def commit(self) -> None:",
    "        assert self.conn is not None",
    "        self.conn.commit()",
])

FILES["app/timeutil.py"] = text([
    "from __future__ import annotations",
    "import time",
    "",
    "",
    "def now_utc_epoch() -> int:",
    "    return int(time.time())",
])

FILES["app/schema.py"] = text([
    "from __future__ import annotations",
    "",
    "from app.db import Database",
    "",
    "",
    "def init_schema(db: Database) -> None:",
    "    db.execute(",
    "        \"\"\"",
    "        CREATE TABLE IF NOT EXISTS users (",
    "            id INTEGER PRIMARY KEY AUTOINCREMENT,",
    "            name TEXT NOT NULL UNIQUE,",
    "            role TEXT NOT NULL CHECK(role IN ('ADMIN','USER')),",
    "            active INTEGER NOT NULL DEFAULT 1",
    "        );",
    "        \"\"\"",
    "    )",
    "    db.execute(",
    "        \"\"\"",
    "        CREATE TABLE IF NOT EXISTS app_lock (",
    "            id INTEGER PRIMARY KEY CHECK (id = 1),",
    "            locked_by_user_id INTEGER,",
    "            locked_by_name TEXT,",
    "            locked_at_utc INTEGER,",
    "            heartbeat_at_utc INTEGER",
    "        );",
    "        \"\"\"",
    "    )",
    "    db.execute(",
    "        \"\"\"",
    "        CREATE TABLE IF NOT EXISTS audit_log (",
    "            id INTEGER PRIMARY KEY AUTOINCREMENT,",
    "            created_at_utc INTEGER NOT NULL,",
    "            actor_name TEXT NOT NULL,",
    "            action TEXT NOT NULL,",
    "            details TEXT",
    "        );",
    "        \"\"\"",
    "    )",
    "    db.execute(\"INSERT OR IGNORE INTO app_lock (id) VALUES (1);\")",
    "    db.execute(\"INSERT OR IGNORE INTO users (name, role, active) VALUES ('Admin','ADMIN',1);\")",
    "    db.commit()",
])

FILES["app/lock.py"] = text([
    "from __future__ import annotations",
    "",
    "from dataclasses import dataclass",
    "",
    "from app.db import Database",
    "from app.timeutil import now_utc_epoch",
    "",
    "",
    "LOCK_TIMEOUT_SECONDS = 5 * 60",
    "HEARTBEAT_INTERVAL_SECONDS = 20",
    "",
    "",
    "@dataclass",
    "class LockState:",
    "    locked_by_name: str | None",
    "    heartbeat_at_utc: int | None",
    "    locked_at_utc: int | None",
    "",
    "    def is_locked(self) -> bool:",
    "        return bool(self.locked_by_name)",
    "",
    "    def is_expired(self) -> bool:",
    "        if not self.is_locked():",
    "            return False",
    "        if self.heartbeat_at_utc is None:",
    "            return True",
    "        return (now_utc_epoch() - self.heartbeat_at_utc) > LOCK_TIMEOUT_SECONDS",
    "",
    "",
    "def get_lock_state(db: Database) -> LockState:",
    "    row = db.execute(",
    "        'SELECT locked_by_name, locked_at_utc, heartbeat_at_utc FROM app_lock WHERE id=1;'",
    "    ).fetchone()",
    "    return LockState(",
    "        locked_by_name=row['locked_by_name'],",
    "        locked_at_utc=row['locked_at_utc'],",
    "        heartbeat_at_utc=row['heartbeat_at_utc'],",
    "    )",
    "",
    "",
    "def try_acquire_lock(db: Database, user_id: int, user_name: str) -> bool:",
    "    now = now_utc_epoch()",
    "    cur = db.execute(",
    "        \"\"\"",
    "        UPDATE app_lock",
    "        SET locked_by_user_id = ?,",
    "            locked_by_name = ?,",
    "            locked_at_utc = ?,",
    "            heartbeat_at_utc = ?",
    "        WHERE id = 1",
    "          AND (",
    "               locked_by_name IS NULL",
    "               OR heartbeat_at_utc IS NULL",
    "               OR (? - heartbeat_at_utc) > ?",
    "          );",
    "        \"\"\"",
    "    , (user_id, user_name, now, now, now, LOCK_TIMEOUT_SECONDS))",
    "    db.commit()",
    "    return cur.rowcount == 1",
    "",
    "",
    "def refresh_heartbeat(db: Database, user_name: str) -> None:",
    "    now = now_utc_epoch()",
    "    db.execute(",
    "        'UPDATE app_lock SET heartbeat_at_utc = ? WHERE id=1 AND locked_by_name = ?;'",
    "    , (now, user_name))",
    "    db.commit()",
    "",
    "",
    "def force_release_lock(db: Database, actor_name: str, reason: str = 'Admin feloldás') -> None:",
    "    db.execute(",
    "        \"\"\"",
    "        UPDATE app_lock",
    "        SET locked_by_user_id = NULL,",
    "            locked_by_name = NULL,",
    "            locked_at_utc = NULL,",
    "            heartbeat_at_utc = NULL",
    "        WHERE id=1;",
    "        \"\"\"",
    "    )",
    "    db.execute(",
    "        'INSERT INTO audit_log (created_at_utc, actor_name, action, details) VALUES (?,?,?,?);'",
    "    , (now_utc_epoch(), actor_name, 'LOCK_RELEASE', reason))",
    "    db.commit()",
])

FILES["app/repo.py"] = text([
    "from __future__ import annotations",
    "",
    "from app.db import Database",
    "from app.timeutil import now_utc_epoch",
    "",
    "",
    "def list_active_users(db: Database) -> list[dict]:",
    "    rows = db.execute(",
    "        \"SELECT id, name, role FROM users WHERE active=1 ORDER BY role DESC, name ASC;\"",
    "    ).fetchall()",
    "    return [dict(r) for r in rows]",
    "",
    "",
    "def create_user(db: Database, name: str) -> None:",
    "    db.execute(\"INSERT INTO users (name, role, active) VALUES (?, 'USER', 1);\", (name,))",
    "    db.commit()",
    "",
    "",
    "def deactivate_user(db: Database, user_id: int) -> None:",
    "    db.execute(\"UPDATE users SET active=0 WHERE id=?;\", (user_id,))",
    "    db.commit()",
    "",
    "",
    "def audit(db: Database, actor_name: str, action: str, details: str = '') -> None:",
    "    db.execute(",
    "        'INSERT INTO audit_log (created_at_utc, actor_name, action, details) VALUES (?,?,?,?);'",
    "    , (now_utc_epoch(), actor_name, action, details))",
    "    db.commit()",
])

FILES["app/bootstrap.py"] = text([
    "from __future__ import annotations",
    "",
    "from app.config import ensure_default_config_exists",
    "from app.db import Database",
    "from app.schema import init_schema",
    "from ui.login import LoginWidget",
    "from ui.main_window import MainWindow",
    "",
    "",
    "def bootstrap_app():",
    "    ensure_default_config_exists()",
    "    db = Database()",
    "    db.connect_or_prompt_and_connect(parent=None)",
    "    init_schema(db)",
    "",
    "    main = MainWindow(db=db)",
    "    login = LoginWidget(db=db, on_logged_in=lambda user, lock_acquired: _finish_login(main, user, lock_acquired))",
    "    main.setCentralWidget(login)",
    "    main.resize(520, 260)",
    "    return main",
    "",
    "",
    "def _finish_login(main: MainWindow, user: dict, lock_acquired: bool) -> None:",
    "    main.setCentralWidget(main.root)",
    "    main.set_session(user, lock_acquired)",
    "    main.resize(520, 320)",
])

# --- ui package ---
FILES["ui/__init__.py"] = text(["# ui package"])

FILES["ui/login.py"] = text([
    "from __future__ import annotations",
    "",
    "from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QComboBox, QPushButton, QMessageBox",
    "",
    "from app.db import Database",
    "from app.lock import get_lock_state, try_acquire_lock",
    "from app.repo import list_active_users, audit",
    "",
    "",
    "class LoginWidget(QWidget):",
    "    def __init__(self, db: Database, on_logged_in):",
    "        super().__init__()",
    "        self.db = db",
    "        self.on_logged_in = on_logged_in",
    "        self.setWindowTitle('Biztonság szervezet - TERVEZŐ program (Bejelentkezés)')",
    "",
    "        layout = QVBoxLayout(self)",
    "        layout.addWidget(QLabel('Felhasználó kiválasztása (jelszó nélkül):'))",
    "",
    "        self.cmb = QComboBox()",
    "        layout.addWidget(self.cmb)",
    "",
    "        self.btn_login = QPushButton('Belépés')",
    "        self.btn_login.clicked.connect(self.login)",
    "        layout.addWidget(self.btn_login)",
    "",
    "        self.lbl_lock = QLabel('')",
    "        self.lbl_lock.setStyleSheet('color: #555;')",
    "        layout.addWidget(self.lbl_lock)",
    "",
    "        self.reload_users()",
    "",
    "    def reload_users(self):",
    "        self.cmb.clear()",
    "        users = list_active_users(self.db)",
    "        for u in users:",
    "            self.cmb.addItem(f\"{u['name']} ({u['role']})\", u)",
    "        self.refresh_lock_label()",
    "",
    "    def refresh_lock_label(self):",
    "        st = get_lock_state(self.db)",
    "        if st.is_locked() and not st.is_expired():",
    "            self.lbl_lock.setText(f\"Jelenleg zárolva: {st.locked_by_name}\")",
    "        elif st.is_locked() and st.is_expired():",
    "            self.lbl_lock.setText(f\"Zárolás lejárt (5 perc): {st.locked_by_name}\")",
    "        else:",
    "            self.lbl_lock.setText('Nincs zárolás.')",
    "",
    "    def login(self):",
    "        u = self.cmb.currentData()",
    "        if not u:",
    "            return",
    "",
    "        name = u['name']",
    "        role = u['role']",
    "        user_id = u['id']",
    "",
    "        if role == 'ADMIN':",
    "            audit(self.db, name, 'LOGIN_ADMIN', 'Admin belépés (Beállítások engedélyezett)')",
    "            self.on_logged_in(u, lock_acquired=False)",
    "            return",
    "",
    "        ok = try_acquire_lock(self.db, user_id=user_id, user_name=name)",
    "        if not ok:",
    "            st = get_lock_state(self.db)",
    "            QMessageBox.warning(",
    "                self,",
    "                'Zárolt a program',",
    "                f\"A programot jelenleg használja: {st.locked_by_name}\\n\\n\"",
    "                'Ha 5 percig nincs aktivitás, a zárolás automatikusan lejár.\\n'",
    "                'Admin a Beállításokban feloldhatja.'",
    "            )",
    "            self.refresh_lock_label()",
    "            return",
    "",
    "        audit(self.db, name, 'LOGIN_USER', 'User belépés + lock megszerezve')",
    "        self.on_logged_in(u, lock_acquired=True)",
])

FILES["ui/main_window.py"] = text([
    "from __future__ import annotations",
    "",
    "from PySide6.QtCore import QTimer",
    "from PySide6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QLabel, QPushButton, QMessageBox",
    "",
    "from app.db import Database",
    "from app.lock import HEARTBEAT_INTERVAL_SECONDS, refresh_heartbeat",
    "from app.repo import audit",
    "",
    "",
    "class MainWindow(QMainWindow):",
    "    def __init__(self, db: Database):",
    "        super().__init__()",
    "        self.db = db",
    "        self.current_user: dict | None = None",
    "        self.lock_acquired: bool = False",
    "        self._heartbeat_timer: QTimer | None = None",
    "",
    "        self.setWindowTitle('Biztonság szervezet - TERVEZŐ program')",
    "",
    "        self.root = QWidget()",
    "        self.layout = QVBoxLayout(self.root)",
    "",
    "        self.lbl_user = QLabel('Nincs bejelentkezve.')",
    "        self.layout.addWidget(self.lbl_user)",
    "",
    "        self.btn_settings = QPushButton('1) Beállítások')",
    "        self.btn_settings.clicked.connect(self.open_settings)",
    "        self.layout.addWidget(self.btn_settings)",
    "",
    "        self.btn_leave = QPushButton('2) Szabadság tervező')",
    "        self.btn_leave.clicked.connect(self.open_leave)",
    "        self.layout.addWidget(self.btn_leave)",
    "",
    "        self.btn_oncall = QPushButton('3) Készenlét tervező')",
    "        self.btn_oncall.clicked.connect(self.open_oncall)",
    "        self.layout.addWidget(self.btn_oncall)",
    "",
    "        self.btn_logout = QPushButton('Kijelentkezés')",
    "        self.btn_logout.clicked.connect(self.logout)",
    "        self.layout.addWidget(self.btn_logout)",
    "",
    "        self.lbl_db = QLabel('')",
    "        self.lbl_db.setStyleSheet('color: #666;')",
    "        self.layout.addWidget(self.lbl_db)",
    "",
    "        self._apply_permissions()",
    "",
    "    def set_session(self, user: dict, lock_acquired: bool):",
    "        self.current_user = user",
    "        self.lock_acquired = lock_acquired",
    "        self.lbl_user.setText(f\"Bejelentkezve: {user['name']} ({user['role']})\")",
    "        self.lbl_db.setText(f\"DB: {self.db.db_path}\")",
    "        self._apply_permissions()",
    "        self._start_heartbeat_if_needed()",
    "",
    "    def _apply_permissions(self):",
    "        if not self.current_user:",
    "            self.btn_settings.setEnabled(False)",
    "            self.btn_leave.setEnabled(False)",
    "            self.btn_oncall.setEnabled(False)",
    "            return",
    "        role = self.current_user['role']",
    "        if role == 'ADMIN':",
    "            self.btn_settings.setEnabled(True)",
    "            self.btn_leave.setEnabled(False)",
    "            self.btn_oncall.setEnabled(False)",
    "        else:",
    "            self.btn_settings.setEnabled(True)",
    "            self.btn_leave.setEnabled(True)",
    "            self.btn_oncall.setEnabled(True)",
    "",
    "    def _start_heartbeat_if_needed(self):",
    "        if not self.current_user:",
    "            return",
    "        if self.current_user['role'] == 'ADMIN':",
    "            return",
    "        if not self.lock_acquired:",
    "            return",
    "        if self._heartbeat_timer is None:",
    "            self._heartbeat_timer = QTimer(self)",
    "            self._heartbeat_timer.setInterval(HEARTBEAT_INTERVAL_SECONDS * 1000)",
    "            self._heartbeat_timer.timeout.connect(self._heartbeat_tick)",
    "            self._heartbeat_timer.start()",
    "",
    "    def _heartbeat_tick(self):",
    "        if not self.current_user:",
    "            return",
    "        try:",
    "            refresh_heartbeat(self.db, user_name=self.current_user['name'])",
    "        except Exception:",
    "            pass",
    "",
    "    def open_settings(self):",
    "        from ui.settings_window import SettingsWindow",
    "        w = SettingsWindow(self.db, self.current_user)",
    "        w.show()",
    "",
    "    def open_leave(self):",
    "        QMessageBox.information(self, 'Szabadság tervező', 'Következő lépésben implementáljuk.')",
    "",
    "    def open_oncall(self):",
    "        QMessageBox.information(self, 'Készenlét tervező', 'Következő lépésben implementáljuk.')",
    "",
    "    def logout(self):",
    "        if not self.current_user:",
    "            return",
    "        audit(self.db, self.current_user['name'], 'LOGOUT', '')",
    "        QMessageBox.information(self, 'Kijelentkezés', 'Kijelentkezve. A belépéshez indítsd újra az alkalmazást.')",
    "",
    "    def closeEvent(self, event):",
    "        event.accept()",
])

FILES["ui/settings_window.py"] = text([
    "from __future__ import annotations",
    "",
    "from PySide6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton, QMessageBox, QHBoxLayout, QLineEdit, QListWidget, QListWidgetItem",
    "",
    "from app.db import Database",
    "from app.lock import get_lock_state, force_release_lock",
    "from app.repo import list_active_users, create_user, deactivate_user, audit",
    "",
    "",
    "class SettingsWindow(QWidget):",
    "    def __init__(self, db: Database, current_user: dict):",
    "        super().__init__()",
    "        self.db = db",
    "        self.current_user = current_user",
    "        self.setWindowTitle('Beállítások')",
    "",
    "        layout = QVBoxLayout(self)",
    "        layout.addWidget(QLabel(f\"Bejelentkezve: {current_user['name']} ({current_user['role']})\"))",
    "",
    "        self.lbl_lock = QLabel('')",
    "        layout.addWidget(self.lbl_lock)",
    "",
    "        btn_refresh = QPushButton('Zárolás állapot frissítése')",
    "        btn_refresh.clicked.connect(self.refresh_lock)",
    "        layout.addWidget(btn_refresh)",
    "",
    "        self.btn_unlock = QPushButton('Zárolás feloldása (ADMIN)')",
    "        self.btn_unlock.clicked.connect(self.unlock)",
    "        layout.addWidget(self.btn_unlock)",
    "",
    "        layout.addWidget(QLabel('—'))",
    "        layout.addWidget(QLabel('Felhasználók (ADMIN):'))",
    "",
    "        row = QHBoxLayout()",
    "        self.txt_new_user = QLineEdit()",
    "        self.txt_new_user.setPlaceholderText('Új felhasználó neve')",
    "        row.addWidget(self.txt_new_user)",
    "        btn_add = QPushButton('Hozzáadás')",
    "        btn_add.clicked.connect(self.add_user)",
    "        row.addWidget(btn_add)",
    "        layout.addLayout(row)",
    "",
    "        self.list_users = QListWidget()",
    "        layout.addWidget(self.list_users)",
    "",
    "        btn_del = QPushButton('Kijelölt felhasználó deaktiválása')",
    "        btn_del.clicked.connect(self.deactivate_selected)",
    "        layout.addWidget(btn_del)",
    "",
    "        self._apply_permissions()",
    "        self.refresh_lock()",
    "        self.reload_users()",
    "",
    "    def _apply_permissions(self):",
    "        is_admin = self.current_user['role'] == 'ADMIN'",
    "        self.btn_unlock.setEnabled(is_admin)",
    "        self.txt_new_user.setEnabled(is_admin)",
    "",
    "    def refresh_lock(self):",
    "        st = get_lock_state(self.db)",
    "        if st.is_locked() and not st.is_expired():",
    "            self.lbl_lock.setText(f\"Zárolva: {st.locked_by_name}\")",
    "        elif st.is_locked() and st.is_expired():",
    "            self.lbl_lock.setText(f\"Zárolás lejárt (5 perc): {st.locked_by_name}\")",
    "        else:",
    "            self.lbl_lock.setText('Nincs zárolás.')",
    "",
    "    def unlock(self):",
    "        if self.current_user['role'] != 'ADMIN':",
    "            QMessageBox.warning(self, 'Nincs jogosultság', 'Csak Admin oldhatja fel a zárolást.')",
    "            return",
    "        force_release_lock(self.db, actor_name=self.current_user['name'], reason='Admin feloldás (Beállítások)')",
    "        audit(self.db, self.current_user['name'], 'UNLOCK', 'Admin feloldotta a zárolást')",
    "        QMessageBox.information(self, 'Kész', 'Zárolás feloldva.')",
    "        self.refresh_lock()",
    "",
    "    def reload_users(self):",
    "        self.list_users.clear()",
    "        for u in list_active_users(self.db):",
    "            item = QListWidgetItem(f\"{u['name']} ({u['role']})\")",
    "            item.setData(256, u)",
    "            self.list_users.addItem(item)",
    "",
    "    def add_user(self):",
    "        if self.current_user['role'] != 'ADMIN':",
    "            QMessageBox.warning(self, 'Nincs jogosultság', 'Csak Admin vehet fel felhasználót.')",
    "            return",
    "        name = self.txt_new_user.text().strip()",
    "        if not name:",
    "            return",
    "        try:",
    "            create_user(self.db, name)",
    "            audit(self.db, self.current_user['name'], 'USER_CREATE', name)",
    "            self.txt_new_user.clear()",
    "            self.reload_users()",
    "        except Exception as e:",
    "            QMessageBox.warning(self, 'Hiba', f\"Nem sikerült felvenni: {e}\")",
    "",
    "    def deactivate_selected(self):",
    "        if self.current_user['role'] != 'ADMIN':",
    "            QMessageBox.warning(self, 'Nincs jogosultság', 'Csak Admin törölhet/deaktiválhat.')",
    "            return",
    "        item = self.list_users.currentItem()",
    "        if not item:",
    "            return",
    "        u = item.data(256)",
    "        if u['role'] == 'ADMIN':",
    "            QMessageBox.warning(self, 'Tiltott', 'Az Admin nem deaktiválható.')",
    "            return",
    "        deactivate_user(self.db, u['id'])",
    "        audit(self.db, self.current_user['name'], 'USER_DEACTIVATE', u['name'])",
    "        self.reload_users()",
])

def write_file(root: Path, rel: str, content: str) -> None:
    p = root / rel
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(content, encoding="utf-8")


def main() -> None:
    root = Path(__file__).resolve().parent
    print("Generating into:", root)
    for rel, content in FILES.items():
        write_file(root, rel, content)
        print("  wrote:", rel)
    print("\nKész. Futtatás: python main.py")


if __name__ == "__main__":
    main()
